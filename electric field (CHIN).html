<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é›»å ´æ¨¡æ“¬å™¨ v15 (å®Œæ•´ä¿®å¾©èˆ‡å¼·åŒ–)</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --accent: #4fc3f7; --danger: #ef5350; --success: #66bb6a; }
        body { 
            margin: 0; 
            background: var(--bg); 
            color: var(--text); 
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif; 
            display: flex; 
            flex-direction: row; 
            height: 100vh; 
            overflow: hidden; 
            user-select: none; 
        }
        
        #sidebar { 
            width: 320px; 
            background: var(--panel); 
            padding: 15px; 
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            box-shadow: 2px 0 10px rgba(0,0,0,0.5); 
            z-index: 10; 
            overflow-y: auto; 
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch; 
        }

        @media (max-width: 700px) {
            body { flex-direction: column-reverse; } 
            #sidebar { 
                width: 100%; 
                height: 45%; 
                box-shadow: 0 -2px 10px rgba(0,0,0,0.5); 
                padding: 10px;
                box-sizing: border-box;
            }
            #canvas-wrapper { height: 55%; }
            h2 { font-size: 1rem; margin-bottom: 5px; }
            .control-group { padding: 8px; }
            button { padding: 12px; } 
        }

        h2 { margin: 0; color: var(--accent); font-size: 1.2rem; border-bottom: 1px solid #333; padding-bottom: 10px; }
        h3 { margin: 5px 0; font-size: 0.9rem; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
        .control-group { background: rgba(255,255,255,0.03); padding: 10px; border-radius: 6px; border: 1px solid #333; }
        
        label { display: flex; justify-content: space-between; font-size: 0.9rem; color: #ccc; margin-bottom: 4px; }
        input[type=range] { width: 100%; margin: 5px 0; cursor: pointer; accent-color: var(--accent); height: 24px; }
        select { width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; margin-bottom: 5px; font-family: 'Microsoft JhengHei', sans-serif;}
        
        .limit-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; font-size: 0.8rem; color: #ccc; }
        .limit-row input { width: 45px; background: #222; color: #fff; border: 1px solid #555; border-radius: 4px; padding: 4px; text-align: center; font-family: monospace;}
        
        button { width: 100%; padding: 10px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; cursor: pointer; margin-bottom: 5px; font-size: 0.9rem; transition: background 0.2s; font-family: 'Microsoft JhengHei', sans-serif; }
        button:hover { background: #444; }
        button.active { background: var(--accent); color: #000; font-weight: bold; border: none; }
        button.danger { border-color: var(--danger); color: var(--danger); background: transparent; }
        button.danger:hover { background: var(--danger); color: white; }
        .row { display: flex; gap: 8px; }
        
        #canvas-wrapper { 
            flex-grow: 1; 
            position: relative; 
            cursor: default; 
            touch-action: none; 
            overflow: hidden;
        }
        
        #overlay { position: absolute; top: 10px; right: 10px; pointer-events: none; background: rgba(0,0,0,0.8); padding: 12px; border-radius: 6px; font-size: 0.9rem; line-height: 1.6; border: 1px solid #444; font-family: 'Microsoft JhengHei', sans-serif; }
        .key { color: var(--accent); font-weight: bold; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>é›»å ´æ¨¡æ“¬å™¨ v15</h2>
    <div class="control-group">
        <h3>æª¢è¦–æ¨¡å¼</h3>
        <div class="row">
            <button id="btn-vec" class="active" onclick="setMode('vector')">å‘é‡å ´</button>
            <button id="btn-field" onclick="setMode('field')">é›»åŠ›ç·š</button>
            <button id="btn-traj" onclick="setMode('trajectory')">ç²’å­è»Œè·¡</button>
        </div>
        
        <div id="vector-settings">
            <label>ç¶²æ ¼é–“è·: <span id="dens-val">40px</span></label>
            <input type="range" id="density" min="25" max="100" value="40" step="5" oninput="draw()">
        </div>
        <div id="field-settings" style="display:none;">
            <label>ç·šæ¢å¯†åº¦: <span id="field-dens-val">1.0x</span></label>
            <input type="range" id="field-density" min="0.5" max="3.0" value="1.0" step="0.1" oninput="draw()">
        </div>
        
        <div id="traj-settings" style="display:none;">
            <label style="margin-top: 5px;">èƒŒæ™¯é¡¯ç¤º:</label>
            <select id="traj-bg">
                <option value="vector">å‘é‡å ´ (Vector)</option>
                <option value="field">é›»åŠ›ç·š (Field Lines)</option>
                <option value="blank">ç©ºç™½ (Blank)</option>
            </select>
            <label>æ¸¬è©¦é›»è·é‡ (q): <span id="traj-q-val">10</span></label>
            <input type="range" id="traj-q" min="-50" max="50" value="10" oninput="document.getElementById('traj-q-val').innerText=this.value">
            <p style="font-size: 0.8rem; color: #888; margin: 5px 0;">ğŸ‘‰ åœ¨ç•«å¸ƒç©ºç™½è™•æˆ–<b>å¹³è¡Œæ¿å…§éƒ¨</b> <b>é»æ“Šä¸¦å‘å¾Œæ‹–æ›³</b> ç™¼å°„ç²’å­ã€‚ç¢°æ’å¾Œæœƒè‡ªå‹•æ¶ˆå¤±ã€‚</p>
            <button class="danger" onclick="clearParticles()" style="margin-top: 5px;">æ¸…é™¤æ‰€æœ‰ç²’å­</button>
        </div>
    </div>

    <div class="control-group">
        <h3>æ–°å¢å ´æº</h3>
        <div class="row">
            <button onclick="addPoint(20)">+ é»é›»è·</button>
            <button onclick="addPoint(-20)">- é»é›»è·</button>
            <button onclick="addPlate()">å¹³è¡Œæ¿</button>
        </div>
    </div>

    <div class="control-group" id="props-panel" style="opacity:0.5; pointer-events:none;">
        <h3>å·²é¸ç‰©ä»¶åƒæ•¸</h3>
        <div id="prop-charge">
            <label>é›»è·é‡ (Q): <span id="val-q">0</span></label>
            <input type="range" id="input-q" oninput="updateObj()">
        </div>
        <div id="prop-plate" style="display:none;">
            <label>é›»å£“ (V): <span id="val-v">0</span></label>
            <input type="range" id="input-v" oninput="updateObj()">
            <label>æ¿é–“è· (d): <span id="val-d">0</span></label>
            <input type="range" id="input-d" oninput="updateObj()">
            <label>æ¿é•·åº¦ (L): <span id="val-l">0</span></label>
            <input type="range" id="input-l" oninput="updateObj()">
        </div>
        <button class="danger" onclick="deleteObj()">åˆªé™¤é¸å–ç‰©ä»¶</button>
    </div>

    <div class="control-group">
        <h3>åƒæ•¸ç¯„åœé™åˆ¶ (Limits)</h3>
        <div class="limit-row"><span>é›»è·(Q)</span><div>Min <input type="number" id="l-q-min" value="-50" onchange="updateLimits()"> Max <input type="number" id="l-q-max" value="50" onchange="updateLimits()"></div></div>
        <div class="limit-row"><span>é›»å£“(V)</span><div>Min <input type="number" id="l-v-min" value="-50" onchange="updateLimits()"> Max <input type="number" id="l-v-max" value="50" onchange="updateLimits()"></div></div>
        <div class="limit-row"><span>é–“è·(d)</span><div>Min <input type="number" id="l-d-min" value="30" onchange="updateLimits()"> Max <input type="number" id="l-d-max" value="1000" onchange="updateLimits()"></div></div>
        <div class="limit-row"><span>é•·åº¦(L)</span><div>Min <input type="number" id="l-l-min" value="50" onchange="updateLimits()"> Max <input type="number" id="l-l-max" value="1000" onchange="updateLimits()"></div></div>
    </div>

    <div class="control-group">
        <button onclick="resetCamera()">é‡ç½®è¦–è§’</button>
        <button class="danger" onclick="clearAll()">æ¸…é™¤å…¨éƒ¨å ´æº</button>
    </div>
</div>

<div id="canvas-wrapper">
    <canvas id="simCanvas"></canvas>
    <div id="overlay">
        <span class="key">æ‹–æ›³ç‰©ä»¶</span> ç§»å‹•ä½ç½®<br>
        <span class="key">æ‹–æ›³èƒŒæ™¯</span> å¹³ç§»ç•«å¸ƒ<br>
        <span class="key">é›™æŒ‡ç¸®æ”¾</span> ç¸®æ”¾ç•«é¢<br>
        <hr style="border: 0; border-top: 1px solid #555; margin: 5px 0;">
        <span id="overlay-mode-hint">
        <b>å‘é‡æ¨¡å¼èªªæ˜ï¼š</b><br>
        <span class="key">é•·æŒ‰ä¸”ä¸ç§»å‹•</span> é»æ“ŠèƒŒæ™¯<br>
        å¯æŸ¥çœ‹è©²é»çš„åˆ†é‡å‘é‡ã€‚
        </span>
    </div>
</div>

<script>
/** CONFIGURATION */
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const k = 8000; 

let objects = [];
let testParticles = []; 
let mode = 'vector'; 
let camera = { x: 0, y: 0, zoom: 1 };
let selectedObj = null;
let draggingObj = null;
let isPanning = false;
let isHoldingView = false;
let isAiming = false; 
let aimStart = {x:0, y:0};
let aimCurrent = {x:0, y:0};
let lastMouse = { x: 0, y: 0 };
let startPointerPos = { x: 0, y: 0 };
let lastPinchDist = null; 

// UI Elements
const uiProps = document.getElementById('props-panel');
const uiVecSettings = document.getElementById('vector-settings');
const uiFieldSettings = document.getElementById('field-settings');
const uiTrajSettings = document.getElementById('traj-settings');
const inputQ = document.getElementById('input-q');
const inputV = document.getElementById('input-v');
const inputD = document.getElementById('input-d');
const inputL = document.getElementById('input-l');
const labelQ = document.getElementById('val-q');
const labelV = document.getElementById('val-v');
const labelD = document.getElementById('val-d');
const labelL = document.getElementById('val-l');
const labelDens = document.getElementById('dens-val');
const labelFieldDens = document.getElementById('field-dens-val');

/** CLASSES */
class PointCharge {
    constructor(x, y, q) {
        this.type = 'point';
        this.x = x;
        this.y = y;
        this.q = q;
        this.r = 15; 
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fillStyle = this.q > 0 ? '#ff4444' : '#2979ff';
        ctx.fill();
        ctx.lineWidth = selectedObj === this ? 3 : 1;
        ctx.strokeStyle = selectedObj === this ? '#ffff00' : '#fff';
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.q > 0 ? '+'+this.q : this.q, this.x, this.y);
    }
    getField(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        const dist2 = dx*dx + dy*dy;
        const dist = Math.sqrt(dist2);
        if (dist < this.r) return {x:0, y:0}; 
        const E = (k * this.q) / dist2;
        return { x: E * (dx/dist), y: E * (dy/dist) };
    }
}

class Plate {
    constructor(x, y, v) {
        this.type = 'plate';
        this.x = x;
        this.y = y;
        this.v = v;
        this.sep = 80;
        this.width = 160; 
    }
    draw(ctx) {
        const halfW = this.width/2;
        const halfH = this.sep/2;
        ctx.save();
        ctx.translate(this.x, this.y);
        const colTop = this.v > 0 ? '#ff4444' : '#2979ff';
        const colBot = this.v > 0 ? '#2979ff' : '#ff4444';
        
        ctx.lineWidth = 5;
        ctx.strokeStyle = colTop;
        ctx.beginPath(); ctx.moveTo(-halfW, -halfH); ctx.lineTo(halfW, -halfH); ctx.stroke();
        ctx.strokeStyle = colBot;
        ctx.beginPath(); ctx.moveTo(-halfW, halfH); ctx.lineTo(halfW, halfH); ctx.stroke();

        if (selectedObj === this) {
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 1;
            ctx.setLineDash([5,5]);
            ctx.strokeRect(-halfW-10, -halfH-10, this.width+20, this.sep+20);
        }
        ctx.restore();
    }
    getField(x, y) {
        const dx = x - this.x;
        const dy = y - this.y;
        const halfW = this.width/2;
        const halfH = this.sep/2;
        
        if (Math.abs(dx) < halfW && Math.abs(dy) < halfH) {
            return { x: 0, y: (this.v * 80) / this.sep };
        }
        return {x:0, y:0};
    }
}

class TestParticle {
    constructor(x, y, vx, vy, q) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.q = q;
        this.trail = [];
        this.active = true;
        this.color = q > 0 ? '#ff8888' : (q < 0 ? '#8888ff' : '#ffffff');
    }
    update() {
        if (!this.active) return;
        
        if (this.trail.length === 0 || Math.hypot(this.x - this.trail[this.trail.length-1].x, this.y - this.trail[this.trail.length-1].y) > 3) {
            this.trail.push({x: this.x, y: this.y});
            if (this.trail.length > 250) this.trail.shift(); 
        }

        let F = getNetField(this.x, this.y);
        
        let forceScale = 0.05;
        let ax = this.q * F.x * forceScale;
        let ay = this.q * F.y * forceScale;

        this.vx += ax;
        this.vy += ay;
        this.x += this.vx;
        this.y += this.vy;

        for (let o of objects) {
            if (o.type === 'point') {
                if (Math.hypot(this.x - o.x, this.y - o.y) < o.r) {
                    this.active = false; 
                }
            } else if (o.type === 'plate') {
                const halfW = o.width/2;
                const halfH = o.sep/2;
                if (Math.abs(this.x - o.x) < halfW) {
                     // ç¢°æ’é‡‘å±¬æ¿å³æ¶ˆå¤±
                     if (Math.abs(Math.abs(this.y - o.y) - halfH) < 5) {
                         this.active = false;
                     }
                }
            }
        }
        if (Math.abs(this.x - camera.x) > 4000 || Math.abs(this.y - camera.y) > 4000) this.active = false;
    }
    draw(ctx) {
        if (this.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for(let i=1; i<this.trail.length; i++) {
                ctx.lineTo(this.trail[i].x, this.trail[i].y);
            }
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }
        
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        ctx.stroke();

        let vMag = Math.hypot(this.vx, this.vy);
        if (vMag > 0.5) {
            let vLen = Math.min(60, vMag * 5); 
            let vAngle = Math.atan2(this.vy, this.vx);
            let endX = this.x + Math.cos(vAngle) * vLen;
            let endY = this.y + Math.sin(vAngle) * vLen;
            
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#00ff00'; 
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(endX - 6 * Math.cos(vAngle - Math.PI/6), endY - 6 * Math.sin(vAngle - Math.PI/6));
            ctx.lineTo(endX - 6 * Math.cos(vAngle + Math.PI/6), endY - 6 * Math.sin(vAngle + Math.PI/6));
            ctx.fillStyle = '#00ff00';
            ctx.fill();
        }
    }
}

/** ENGINE */
function init() {
    window.addEventListener('resize', resize);
    resize();
    updateLimits(); 
    
    // Tweak 4: é è¨­å…©å€‹æ­£é›»è·
    objects.push(new PointCharge(-100, 0, 20));
    objects.push(new PointCharge(100, 0, 20)); 

    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mouseup', onPointerUp);
    window.addEventListener('mousemove', onPointerMove);
    canvas.addEventListener('wheel', onWheel, {passive:false});
    canvas.addEventListener('contextmenu', e=>e.preventDefault());

    canvas.addEventListener('touchstart', onPointerDown, {passive: false});
    window.addEventListener('touchend', onPointerUp);
    canvas.addEventListener('touchmove', onPointerMove, {passive: false});

    requestAnimationFrame(loop);
}

function resize() {
    const wrapper = document.getElementById('canvas-wrapper');
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
}

function loop() {
    ctx.fillStyle = "#121212";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);
    ctx.scale(camera.zoom, camera.zoom);

    if (mode === 'vector') {
        drawVectorMode(1.0);
    } else if (mode === 'field') {
        drawFieldMode();
    } else if (mode === 'trajectory') {
        const bgChoice = document.getElementById('traj-bg').value;
        if (bgChoice === 'vector') {
            // Tweak 2b: æé«˜å‘é‡èƒŒæ™¯äº®åº¦ (åŸç‚º 0.25 -> æ”¹ç‚º 0.8)
            drawVectorMode(0.8); 
        } else if (bgChoice === 'field') {
            ctx.globalAlpha = 0.3; 
            drawFieldMode();
            ctx.globalAlpha = 1.0;
        }

        testParticles.forEach(p => p.update());
        testParticles = testParticles.filter(p => p.active); 
        testParticles.forEach(p => p.draw(ctx));

        if (isAiming) {
            ctx.beginPath();
            ctx.moveTo(aimStart.x, aimStart.y);
            ctx.lineTo(aimCurrent.x, aimCurrent.y);
            ctx.strokeStyle = '#ffeb3b';
            ctx.setLineDash([5,5]);
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);
            
            const qPreview = parseInt(document.getElementById('traj-q').value);
            ctx.beginPath();
            ctx.arc(aimStart.x, aimStart.y, 5, 0, Math.PI*2);
            ctx.fillStyle = qPreview > 0 ? '#ff8888' : (qPreview < 0 ? '#8888ff' : '#ffffff');
            ctx.fill();
        }
    }

    objects.forEach(o => o.draw(ctx));
    ctx.restore();
    requestAnimationFrame(loop);
}

function getNetField(x, y) {
    let Ex = 0, Ey = 0;
    objects.forEach(o => {
        const f = o.getField(x, y);
        Ex += f.x;
        Ey += f.y;
    });
    return { x: Ex, y: Ey, mag: Math.sqrt(Ex*Ex + Ey*Ey) };
}

function getColor(mag, alpha=1) {
    const t = Math.min(1, mag / 25); 
    const hue = 240 - (t * 240);
    return `hsla(${hue}, 100%, 50%, ${alpha})`;
}

/** VECTOR MODE */
function drawVectorMode(opacityMult = 1.0) {
    const density = parseInt(document.getElementById('density').value);
    if(opacityMult === 1.0) labelDens.innerText = density + "px"; 
    const viewL = -(canvas.width/2 + camera.x)/camera.zoom - 50;
    const viewR = (canvas.width/2 - camera.x)/camera.zoom + 50;
    const viewT = -(canvas.height/2 + camera.y)/camera.zoom - 50;
    const viewB = (canvas.height/2 - camera.y)/camera.zoom + 50;

    for (let x = Math.floor(viewL/density)*density; x < viewR; x += density) {
        for (let y = Math.floor(viewT/density)*density; y < viewB; y += density) {
            if (isHoldingView && mode === 'vector') {
                objects.forEach(obj => {
                    const f = obj.getField(x, y);
                    const mag = Math.sqrt(f.x*f.x + f.y*f.y);
                    if (mag > 0.5) {
                        let col = obj.type === 'point' ? (obj.q > 0 ? '#ff4444' : '#2979ff') : (obj.v > 0 ? '#ff4444' : '#2979ff');
                        drawArrow(ctx, x, y, f.x, f.y, mag, col, 0.6 * opacityMult, 1.0);
                    }
                });
            } else {
                const f = getNetField(x, y);
                if (f.mag > 0.5) drawArrow(ctx, x, y, f.x, f.y, f.mag, getColor(f.mag, opacityMult), opacityMult, 2.0);
            }
        }
    }
}

function drawArrow(ctx, x, y, vx, vy, mag, color, alpha, width) {
    const angle = Math.atan2(vy, vx);
    const len = Math.min(50, 8 + Math.log(mag + 1) * 8); 
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.globalAlpha = alpha;
    ctx.lineWidth = width;
    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(len, 0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(len, 0); ctx.lineTo(len - 4, -3); ctx.lineTo(len - 4, 3); ctx.fill();
    ctx.restore();
}

/** FIELD MODE */
function drawFieldMode() {
    ctx.lineWidth = 1.5;
    let seeds = [];
    const densityMult = parseFloat(document.getElementById('field-density').value);
    labelFieldDens.innerText = densityMult.toFixed(1) + "x";

    // Bug 1: åˆ†é›¢é»é›»è·èˆ‡å¹³è¡Œæ¿çš„æ­£æºæª¢æ¸¬
    const hasPositivePoint = objects.some(o => o.type==='point' && o.q>0);

    objects.forEach(obj => {
        let traceDir = 1; 
        let generate = false;
        let count = 0;

        if (obj.type === 'point') {
            if (obj.q > 0) {
                generate = true;
                count = Math.max(8, Math.floor(obj.q * 1.5 * densityMult));
            } else if (!hasPositivePoint && obj.q < 0) {
                // è‹¥æ²’æœ‰æ­£é»é›»è·ï¼Œè² é›»è·è‡ªè¡Œç”¢ç”Ÿå‘å…§çš„é›»åŠ›ç·š
                generate = true;
                traceDir = -1; 
                count = Math.max(8, Math.floor(Math.abs(obj.q) * 1.5 * densityMult));
            }

            if (generate) {
                for(let i=0; i<count; i++) {
                    const a = (Math.PI*2 * i)/count;
                    seeds.push({ 
                        x: obj.x + Math.cos(a)*(obj.r+2), 
                        y: obj.y + Math.sin(a)*(obj.r+2),
                        dir: traceDir
                    });
                }
            }
        } 
        else if (obj.type === 'plate') {
            const fieldStrength = Math.abs(obj.v) / obj.sep; 
            const calcCount = Math.floor(obj.width * fieldStrength * 2.5 * densityMult);
            count = Math.max(3, Math.min(100, calcCount)); 

            // å¹³è¡Œæ¿æ˜¯ç¨ç«‹ç³»çµ±ï¼Œæœ‰é›»å£“å°±ç”¢ç”Ÿé›»åŠ›ç·š
            if (obj.v > 0) {
                generate = true;
                traceDir = 1;
            } else if (obj.v < 0) {
                generate = true;
                traceDir = -1;
            }

            if (generate) {
                const safeWidth = obj.width * 0.9; 
                const startX = obj.x - safeWidth/2;
                const stepX = safeWidth / count;
                
                for(let i=0; i<=count; i++) {
                    const px = startX + i*stepX;
                    seeds.push({ x: px, y: obj.y - obj.sep/2 + 5, dir: traceDir });
                    seeds.push({ x: px, y: obj.y + obj.sep/2 - 5, dir: traceDir });
                }
            }
        }
    });

    seeds.forEach(p => {
        let path = [];
        let curr = {x: p.x, y: p.y};
        path.push({x: curr.x, y: curr.y});
        let lastDir = null; 

        for(let i=0; i<600; i++) {
            const f = getNetField(curr.x, curr.y);
            
            if (f.mag < 0.2) break; 

            const stepSize = 4; 
            const dirX = (f.x / f.mag) * p.dir; 
            const dirY = (f.y / f.mag) * p.dir;

            if (lastDir) {
                const dot = lastDir.x * dirX + lastDir.y * dirY;
                if (dot < 0.5) break; 
            }
            lastDir = {x: dirX, y: dirY};

            curr.x += dirX * stepSize;
            curr.y += dirY * stepSize;
            path.push({x: curr.x, y: curr.y});

            let hit = false;
            for(let o of objects) {
                const targetSign = p.dir === 1 ? -1 : 1;
                if(o.type === 'point') {
                    const isTarget = (o.q > 0 && targetSign === 1) || (o.q < 0 && targetSign === -1);
                    if (isTarget && ((curr.x-o.x)**2 + (curr.y-o.y)**2 < o.r**2)) hit = true;
                } else if (o.type === 'plate') {
                    const halfW = o.width/2;
                    const halfH = o.sep/2;
                    if (Math.abs(curr.x - o.x) < halfW) {
                         if (Math.abs(Math.abs(curr.y - o.y) - halfH) < 5) hit = true;
                    }
                }
            }
            if(hit) break;
            if (Math.abs(curr.x - camera.x) > canvas.width/camera.zoom + 200) break;
            if (Math.abs(curr.y - camera.y) > canvas.height/camera.zoom + 200) break;
        }

        if (path.length > 1) {
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            ctx.strokeStyle = '#4fc3f7'; 
            for(let i=1; i<path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();

            const totalSteps = path.length;
            if (totalSteps < 50 && totalSteps > 2) {
                const mid = Math.floor(totalSteps / 2);
                drawPathArrow(ctx, path[mid-1], path[mid], p.dir);
            } else {
                for(let i=20; i<totalSteps; i+=40) {
                    drawPathArrow(ctx, path[i-1], path[i], p.dir);
                }
            }
        }
    });
}

function drawPathArrow(ctx, p1, p2, traceDir) {
    let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
    if (traceDir === -1) {
        angle += Math.PI; 
    }
    ctx.save();
    ctx.translate(p2.x, p2.y);
    ctx.rotate(angle);
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(4, 0);
    ctx.lineTo(-4, -3);
    ctx.lineTo(-4, 3);
    ctx.fill();
    ctx.restore();
}

/** INTERACTION (MOUSE + TOUCH) */
function toWorld(sx, sy) {
    return { x: (sx - canvas.width/2 - camera.x) / camera.zoom, y: (sy - canvas.height/2 - camera.y) / camera.zoom };
}

function getPointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    return { x: clientX - rect.left, y: clientY - rect.top };
}

function onPointerDown(e) {
    if(e.type === 'touchstart') e.preventDefault();
    
    if (e.touches && e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastPinchDist = Math.sqrt(dx*dx + dy*dy);
        return;
    }

    const pos = getPointerPos(e);
    startPointerPos = { x: pos.x, y: pos.y }; 
    const m = toWorld(pos.x, pos.y);

    if (e.button === 2) { 
        isPanning = true; 
        lastMouse = {x: pos.x, y: pos.y}; 
        return; 
    }

    const hit = objects.find(o => {
        const hitMargin = e.type === 'touchstart' ? 30 : 10;
        if(o.type === 'point') return ((m.x-o.x)**2 + (m.y-o.y)**2) < (o.r + hitMargin)**2;
        
        if(o.type === 'plate') {
            // Bug 2a: ä¿®æ­£ç¢°æ’ç¯„åœï¼Œåªå…è¨±é»æ“Šé‡‘å±¬æ¿æœ¬èº«é€²è¡Œæ‹–æ›³ï¼Œæ”¾ç©ºå…§éƒ¨å€åŸŸå¯ä¾›ç™¼å°„ç²’å­
            if (Math.abs(m.x - o.x) < o.width/2 + hitMargin) {
                if (Math.abs(Math.abs(m.y - o.y) - o.sep/2) < 10 + hitMargin) return true;
            }
            return false;
        }
    });

    if (hit) { 
        selectObj(hit); 
        draggingObj = hit; 
        isHoldingView = false;
        isPanning = false;
        isAiming = false;
    } else { 
        if (mode === 'trajectory') {
            isAiming = true;
            aimStart = { x: m.x, y: m.y };
            aimCurrent = { x: m.x, y: m.y };
        } else {
            isHoldingView = true; 
            isPanning = false;
            lastMouse = {x: pos.x, y: pos.y}; 
        }
        selectObj(null); 
    }
}

function onPointerMove(e) {
    if(e.type === 'touchmove') e.preventDefault();

    if (e.touches && e.touches.length === 2 && lastPinchDist) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const scale = dist / lastPinchDist;
        camera.zoom = Math.max(0.3, Math.min(4, camera.zoom * scale));
        lastPinchDist = dist;
        return;
    }

    const pos = getPointerPos(e);
    const m = toWorld(pos.x, pos.y);

    if (isAiming) {
        aimCurrent = { x: m.x, y: m.y };
    } else if (isHoldingView && !draggingObj) {
        if (Math.hypot(pos.x - startPointerPos.x, pos.y - startPointerPos.y) > 5) {
            isHoldingView = false;
            isPanning = true;
        }
    }

    if (isPanning) { 
        camera.x += pos.x - lastMouse.x; 
        camera.y += pos.y - lastMouse.y; 
        lastMouse = {x: pos.x, y: pos.y}; 
    } else if (draggingObj) { 
        draggingObj.x = m.x; 
        draggingObj.y = m.y; 
    }
}

function onPointerUp(e) {
    if (isAiming) {
        let q = parseInt(document.getElementById('traj-q').value);
        let vx = (aimStart.x - aimCurrent.x) * 0.1; 
        let vy = (aimStart.y - aimCurrent.y) * 0.1;
        if (Math.hypot(vx, vy) > 0.5) {
            testParticles.push(new TestParticle(aimStart.x, aimStart.y, vx, vy, q));
        }
        isAiming = false;
    }
    isPanning = false; draggingObj = null; isHoldingView = false; lastPinchDist = null;
}

function onWheel(e) { 
    e.preventDefault(); 
    const s = e.deltaY > 0 ? 0.9 : 1.1; 
    camera.zoom = Math.max(0.3, Math.min(4, camera.zoom * s)); 
}

/** UI & LIMITS */
function updateLimits() {
    inputQ.min = document.getElementById('l-q-min').value;
    inputQ.max = document.getElementById('l-q-max').value;
    inputV.min = document.getElementById('l-v-min').value;
    inputV.max = document.getElementById('l-v-max').value;
    inputD.min = document.getElementById('l-d-min').value;
    inputD.max = document.getElementById('l-d-max').value;
    inputL.min = document.getElementById('l-l-min').value;
    inputL.max = document.getElementById('l-l-max').value;
    
    if(selectedObj) selectObj(selectedObj); 
}

function selectObj(obj) {
    selectedObj = obj;
    uiProps.style.opacity = obj ? 1 : 0.5;
    uiProps.style.pointerEvents = obj ? 'auto' : 'none';
    if (!obj) return;

    const isPoint = obj.type === 'point';
    document.getElementById('prop-charge').style.display = isPoint ? 'block' : 'none';
    document.getElementById('prop-plate').style.display = isPoint ? 'none' : 'block';

    if (isPoint) { 
        inputQ.value = obj.q; 
        labelQ.innerText = obj.q > 0 ? "+"+obj.q : obj.q; 
    } else { 
        inputV.value = obj.v; 
        inputD.value = obj.sep; 
        inputL.value = obj.width;
        labelV.innerText = obj.v; 
        labelD.innerText = obj.sep; 
        labelL.innerText = obj.width;
    }
}

function updateObj() {
    if (!selectedObj) return;
    if (selectedObj.type === 'point') { 
        selectedObj.q = parseInt(inputQ.value); 
        labelQ.innerText = selectedObj.q > 0 ? "+"+selectedObj.q : selectedObj.q; 
    } else { 
        selectedObj.v = parseInt(inputV.value); 
        selectedObj.sep = parseInt(inputD.value); 
        selectedObj.width = parseInt(inputL.value);
        labelV.innerText = selectedObj.v; 
        labelD.innerText = selectedObj.sep; 
        labelL.innerText = selectedObj.width; 
    }
}

function addPoint(q) { objects.push(new PointCharge((Math.random()-0.5)*50, (Math.random()-0.5)*50, q)); selectObj(objects[objects.length-1]); }
function addPlate() { objects.push(new Plate(0, 0, 30)); selectObj(objects[objects.length-1]); }
function deleteObj() { if (selectedObj) { objects = objects.filter(o => o !== selectedObj); selectObj(null); } }
function clearAll() { objects = []; selectObj(null); }
function clearParticles() { testParticles = []; }

function setMode(m) { 
    mode = m; 
    document.getElementById('btn-vec').className = mode === 'vector' ? 'active' : ''; 
    document.getElementById('btn-field').className = mode === 'field' ? 'active' : ''; 
    document.getElementById('btn-traj').className = mode === 'trajectory' ? 'active' : ''; 

    uiVecSettings.style.display = (mode === 'vector' || mode === 'trajectory') ? 'block' : 'none'; 
    uiFieldSettings.style.display = mode === 'field' ? 'block' : 'none'; 
    uiTrajSettings.style.display = mode === 'trajectory' ? 'block' : 'none'; 

    const hint = document.getElementById('overlay-mode-hint');
    if (mode === 'trajectory') {
        hint.innerHTML = "<b>è»Œè·¡æ¨¡å¼èªªæ˜ï¼š</b><br>åœ¨èƒŒæ™¯æˆ–å¹³è¡Œæ¿å…§éƒ¨ <span class='key'>å‘å¾Œæ‹–æ›³</span><br>åƒå½ˆå¼“ä¸€æ¨£ç™¼å°„ç²’å­ã€‚";
    } else {
        hint.innerHTML = "<b>å‘é‡æ¨¡å¼èªªæ˜ï¼š</b><br><span class='key'>é•·æŒ‰ä¸”ä¸ç§»å‹•</span> é»æ“ŠèƒŒæ™¯<br>å¯æŸ¥çœ‹è©²é»çš„åˆ†é‡å‘é‡ã€‚";
    }
}

function resetCamera() { camera = {x:0, y:0, zoom:1}; }

init();
</script>
</body>
</html>
